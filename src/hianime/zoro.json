{
  "id": "zoro",
  "name": "HiAnime",
  "description": "",
  "manifestURI": "",
  "version": "1.0.1",
  "author": "ancientcatz",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "en",
  "payload": "/// <reference path=\"./onlinestream-provider.d.ts\" />\n/// <reference path=\"./core.d.ts\" />\n\n// (private) match the API’s result shape\ninterface _AnimeResult {\n    id: string;\n    title: string;\n    url: string;\n    image: string;\n    duration: string;\n    watchList: string;\n    japaneseTitle: string;\n    type: string;\n    nsfw: boolean;\n    sub: number;\n    dub: number;\n    episodes: number;\n}\n\n// (private) just what we need from each page\ninterface _SearchPage {\n    hasNextPage: boolean;\n    results: _AnimeResult[];\n}\n\n// private helper to match the info‐endpoint response\ninterface _InfoResponse {\n    episodes: {\n        id: string;\n        number: number;\n        title: string;\n        url: string;\n        // (we ignore isFiller, isSubbed, isDubbed here)\n    }[];\n}\n\n// private helper to match the watch‐endpoint response\ninterface _WatchResponse {\n    intro: { start: number; end: number };\n    outro: { start: number; end: number };\n    sources: {\n        url: string;\n        isM3U8: boolean;\n        type: string;\n    }[];\n    subtitles: {\n        url: string;\n        lang: string;\n    }[];\n}\n\nclass Provider {\n    apiURL = \"https://d2dd7450351ba6fb.vercel.app\";\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"server1\", \"server2\"],\n            supportsDub: true,\n        };\n    }\n\n    async search(query: SearchOptions): Promise<SearchResult[]> {\n        const keyword = this.normalizeQuery(query.query);\n\n        const allResults: SearchResult[] = [];\n        let page = 1;\n        let hasNext = true;\n\n        while (hasNext) {\n            const url = `${this.apiURL}/anime/zoro/${encodeURIComponent(\n                keyword,\n            )}?page=${page}`;\n            const resp = await fetch(url);\n            if (!resp.ok) {\n                throw new Error(\n                    `Search failed (page ${page}): ${resp.status} ${resp.statusText}`,\n                );\n            }\n\n            // only pick out the bits we care about\n            const { hasNextPage, results } = (await resp.json()) as _SearchPage;\n\n            // map each API result into your SearchResult shape\n            allResults.push(\n                ...results.map((r) => {\n                    // compute a literal of the exact union you're targeting\n                    const subOrDub =\n                        r.sub > 0 && r.dub > 0\n                            ? \"both\"\n                            : r.dub > 0\n                              ? \"dub\"\n                              : \"sub\";\n\n                    return {\n                        id: r.id,\n                        title: r.title,\n                        url: `${this.apiURL}/anime/zoro/info?id=${r.id}`,\n                        // assert it’s the same as your SubOrDub type\n                        subOrDub: subOrDub as SearchResult[\"subOrDub\"],\n                    };\n                }),\n            );\n\n            hasNext = hasNextPage;\n            page++;\n        }\n\n        return allResults;\n    }\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n        const url = `${this.apiURL}/anime/zoro/info?id=${id}`;\n        const resp = await fetch(url);\n        if (!resp.ok) {\n            throw new Error(\n                `Failed to fetch episode info for \"${id}\": ${resp.status} ${resp.statusText}`,\n            );\n        }\n\n        const data = (await resp.json()) as _InfoResponse;\n\n        // map into your EpisodeDetails shape\n        return data.episodes.map((ep) => ({\n            id: ep.id,\n            number: ep.number,\n            url: `${this.apiURL}/anime/zoro/watch/${ep.id}`,\n            title: ep.title,\n        }));\n    }\n    async findEpisodeServer(\n        episode: EpisodeDetails,\n        _server: string,\n    ): Promise<EpisodeServer> {\n        // pick your server name unchanged\n        const serverName = _server === \"default\" ? \"zoro\" : _server;\n\n        // first fetch the watch JSON to get the master URL\n        const watchUrl = `${this.apiURL}/anime/zoro/watch/${encodeURIComponent(\n            episode.id,\n        )}`;\n        const watchResp = await fetch(watchUrl);\n        if (!watchResp.ok) {\n            throw new Error(\n                `Failed to fetch watch info for \"${episode.id}\": ${watchResp.status}`,\n            );\n        }\n        const watchData = (await watchResp.json()) as _WatchResponse;\n\n        // we expect exactly one HLS source with isM3U8 === true\n        const masterEntry = watchData.sources.find((s) => s.isM3U8);\n        if (!masterEntry) {\n            throw new Error(\"No HLS master playlist found\");\n        }\n\n        // fetch the master playlist text\n        const playlistResp = await fetch(masterEntry.url);\n        if (!playlistResp.ok) {\n            throw new Error(\n                `Failed to fetch master playlist: ${playlistResp.status}`,\n            );\n        }\n        const playlistText = await playlistResp.text();\n        const baseUrl = masterEntry.url.replace(/\\/[^/]*$/, \"/\");\n        // everything before the final slash\n\n        // parse out each STREAM-INF line + the next line URI\n        const lines = playlistText.split(\"\\n\");\n        const variants: { res: string; uri: string }[] = [];\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            if (line.startsWith(\"#EXT-X-STREAM-INF:\")) {\n                // extract RESOLUTION=WxH\n                const m = line.match(/RESOLUTION=(\\d+)x(\\d+)/);\n                if (m) {\n                    const height = m[2];\n                    const uri = lines[i + 1]?.trim();\n                    if (uri && !uri.startsWith(\"#\")) {\n                        variants.push({\n                            res: `${height}p`,\n                            uri,\n                        });\n                    }\n                }\n            }\n        }\n\n        // build VideoSource entries\n        const videoSources: VideoSource[] = variants.map((v) => ({\n            url: baseUrl + v.uri,\n            type: \"m3u8\",\n            quality: v.res,\n            subtitles: watchData.subtitles.map((sub, idx) => ({\n                id: `${episode.id}-sub-${idx}`,\n                url: sub.url,\n                language: sub.lang,\n                isDefault: /English/i.test(sub.lang),\n            })),\n        }));\n\n        return {\n            server: serverName,\n            headers: {},\n            videoSources,\n        };\n    }\n    normalizeQuery(query: string): string {\n        const normalizedQuery = query\n            .replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, \"$1\") //Removes suffixes from a number I.e. 3rd, 1st, 11th, 12th, 2nd -> 3, 1, 11, 12, 2\n            .replace(/\\s+/g, \" \") //Replaces 1+ whitespaces with 1 whitespace\n            .replace(/(\\d+)\\s*Season/i, \"$1\") //Removes season and keeps the number before the Season word\n            .replace(/Season\\s*(\\d+)/i, \"$1\") //Removes season and keeps the number after the Season word\n            .trim();\n\n        return normalizedQuery;\n    }\n}\n\n"
}
